# 串口通信一站式工具 (UartTool)

> 本项目旨在一个软件快速解决大部分机器人竞赛之中串口协议调试问题，开源便捷的快速调通协议
> 负责上位机的同学可以使用这个工具快速结合下位机同学给的协议进行实际测试（喔要验牌！）
>
> 下位机同学可以使用这个工具快速替代上位机发送指令和进行解析（牌妹有问题~）

## 软件简介

一个功能完整的串口通信调试工具，支持代码生成、串口调试、帧解析、示波器和终端功能。
### 目前仅仅支持win（linux计划中，待测试）
### 已经实现功能

1. 串口数据收发
2. 快速图形化配置协议
3. 多种协议和解析支持（crc/sum/xor）
4. 快速协议切换
5. 加载协议/扫描文件夹内所有json格式的协议
6. 协议解析，自动解析，手动解析
7. 图形化配置协议发送，协议发送的数据回传方便自己校验
8. 协议发动绑定按键触发
9. 串口示波器
10. 串口解析数据导出

### 待实现的功能

1. 直接通过滑动条快速发送解析数据
2. 终端模式调试
3. linux平台支持
4. 增加pid自主调试接口,接入llm大模型,通过参数数据流自动调试
5. 增加多协议同时解析和示波器显示

## 功能特性

### 1. 代码生成器
- 支持生成 **C**、**C++**、**Python** 三种语言的串口通信代码
- 自动生成 `encode()` 编码函数和 `decode()` 解码函数
- 支持多种校验方式：无校验、CRC8、CRC16、Sum求和、XOR异或
- 支持字节对齐配置（1/2/4/8字节）
- 支持自定义帧头帧尾
- 支持变长帧（包含数据长度字段）

### 2. 串口调试
- 支持常见的波特率设置（9600~921600）
- 支持数据位（5-8）、停止位（1/1.5/2）、校验位（无/奇/偶）配置
- 支持 ASCII 和 HEX 模式收发
- 支持中文编码（GBK/UTF-8/GB2312/ASCII/Latin-1）
- 支持循环发送功能（间隔可调：10-10000ms）
- 实时发送/接收计数
- 自动检测串口拔出，提示并自动关闭

### 3. 帧解析
- 支持多协议同时解析
- 加载多个 JSON 协议文件
- 自动识别协议并解析数据
- 支持手动解析（输入HEX数据测试）
- 支持字节序配置（小端/大端）
- 独立帧解析窗口（可弹出演示波器窗口）

### 4. 串口示波器
- 实时显示接收数据波形
- 内嵌示波器 + 独立示波器窗口
- 可配置显示点数（10~1000）
- 支持变量类型转换（uint16→float、int16→float、byte_swap等）
- 支持导出CSV数据
- 支持暂停/继续波形刷新
- 支持鼠标滚轮缩放和拖拽平移

### 5. 终端功能
- 内嵌终端模式
- 独立终端窗口
- 支持本地回显
- 支持显示HEX原始数据
- 支持配置Linux串口参数

### 6. 键盘映射
- 8个快捷键槽位（F1-F8）
- 捕获键盘按键
- 绑定协议和预设值
- 一键发送预设数据

### 7. 主题切换
- 深色主题（默认）
- 浅色主题
- 主题自动应用到所有窗口

---

## 快速开始

### 启动软件

双击运行 `dist/UartTool.exe`

### 基础使用流程

1. **连接串口**：选择串口 → 设置波特率 → 点击"打开串口"
2. **发送数据**：输入内容 → 选择模式（ASCII/HEX）→ 点击"发送"
3. **接收数据**：自动显示在接收区，可切换HEX/ASCII查看

---

## 详细功能说明

### 一、结构体配置标签页

用于定义通信协议结构，并生成对应语言的解析代码。

#### 1.1 基本设置
| 配置项 | 说明 |
|--------|------|
| structName | 协议/结构体名称 |
| 字节序 | 小端(Little Endian) / 大端(Big Endian) |

#### 1.2 帧头帧尾配置
| 配置项 | 说明 |
|--------|------|
| Header | 帧头值（0-255）和字节数（1-8） |
| Footer | 帧尾值（0-255）和字节数（1-8） |
| 包含data_len | 是否包含数据长度字段 |

#### 1.3 高级选项
| 配置项 | 说明 |
|--------|------|
| 校验方式 | 无校验 / CRC8 / CRC16 / 求和 / 异或 |
| 字节对齐 | 1 / 2 / 4 / 8 字节 |
| 长度模式 | 仅数据 / 含校验 / 完整帧 |

#### 1.4 字段表格
点击"添加字段"添加新字段：
- **name**：字段名称
- **type**：数据类型（int, uint8, uint16, int8, int16, float, char, bool）
- **char_length**：字符长度（仅char类型需要）

#### 1.5 代码生成
点击"生成代码"按钮，选择语言（Python / C / C++），生成对应语言的解析代码。

---

### 二、串口调试标签页

#### 2.1 串口配置区域

| 配置项 | 说明 |
|--------|------|
| 串口选择 | 下拉选择可用串口，或输入自定义路径 |
| 刷新按钮 | 刷新串口列表 |
| 波特率 | 9600 / 19200 / 38400 / 57600 / 115200 / 230400 / 460800 / 921600 |
| 数据位 | 5 / 6 / 7 / 8 |
| 停止位 | 1 / 1.5 / 2 |
| 校验位 | 无 / 奇校验 / 偶校验 |

**打开/关闭串口**：点击对应按钮连接或断开串口

#### 2.2 发送区域

| 配置项 | 说明 |
|--------|------|
| 发送模式 | ASCII / HEX（单选） |
| 发送编码 | GBK / UTF-8 / GB2312 / ASCII / Latin-1 |
| 发送文本框 | 输入要发送的数据 |
| 发送按钮 | 发送数据 |
| 循环发送 | 勾选后自动循环发送 |
| 发送间隔 | 循环发送间隔（10-10000ms） |
| 发送计数 | 显示累计发送字节数 |

#### 2.3 接收区域

| 配置项 | 说明 |
|--------|------|
| 接收模式 | ASCII / HEX |
| 接收编码 | GBK / UTF-8 / GB2312 / ASCII / Latin-1 |
| 自动滚屏 | 勾选后自动滚动到最新数据 |
| 自动解析 | 勾选后自动按协议解析数据 |
| 接收计数 | 显示累计接收字节数 |
| 清空接收 | 清空接收区内容 |

#### 2.4 协议解析区域

| 配置项 | 说明 |
|--------|------|
| 扫描协议 | 扫描examples文件夹加载所有协议 |
| 协议选择 | 选择当前使用的协议 |
| 加载协议 | 手动加载单个协议文件 |
| 编辑协议 | 用结构体编辑器打开协议 |
| 字节序 | 小端 / 大端 |
| 多协议自动解析 | 勾选后自动识别多个协议 |

#### 2.5 示波器区域

| 配置项 | 说明 |
|--------|------|
| 启用示波器 | 开启/关闭波形显示 |
| 显示点数 | 设置显示的数据点数 |
| 清空波形 | 清空波形数据 |
| 弹出演示波器窗口 | 打开独立示波器窗口 |

#### 2.6 终端区域

| 配置项 | 说明 |
|--------|------|
| 启用终端模式 | 开启终端显示模式 |
| 提示符 | 设置终端提示符 |
| 编码 | 选择终端编码 |
| 显示HEX | 以十六进制显示原始数据 |
| 本地回显 | 显示发送的命令 |
| 弹出终端窗口 | 打开独立终端窗口 |

#### 2.7 键盘映射区域

支持8个快捷键槽位，每个槽位可以：
- 捕获键盘按键
- 选择绑定的协议
- 设置发送的值
- 测试发送

---

### 三、独立窗口

#### 3.1 帧解析窗口

点击"弹出帧解析窗口"按钮打开独立窗口：

| 功能 | 说明 |
|------|------|
| 协议选择 | 选择要使用的协议 |
| 加载协议 | 加载JSON协议文件 |
| 自定义协议 | 手动输入协议内容 |
| 多协议自动解析 | 自动识别多个协议 |
| 输入(HEX) | 输入十六进制数据 |
| 手动解析 | 手动解析输入的数据 |
| 解析结果 | 显示解析后的字段和值 |
| 协议内容 | 显示当前协议的JSON内容 |

#### 3.2 示波器窗口

点击"弹出演示波器窗口"按钮打开独立窗口：

| 功能 | 说明 |
|------|------|
| 启用 | 开启/关闭示波器 |
| 显示点数 | 设置显示的数据点数（10-1000） |
| 清空 | 清空所有数据 |
| 缓存时间 | 数据缓存时间（1-3600秒） |
| 导出数据 | 导出为CSV文件 |
| 暂停/继续 | 暂停/恢复波形刷新 |
| 自适应窗口 | 自动调整坐标轴 |
| 显示模式 | 原始数据 / 解析变量 |
| 变量选择 | 选择要显示的变量，设置类型转换和倍率 |

**类型转换选项**：
- 无
- uint16→float / int16→float / uint32→float / int32→float
- uint8→int / uint16→int / int16→int
- byte_swap_16 / byte_swap_32

**鼠标操作**：
- 滚轮：缩放图表
- 拖拽：平移图表
- 鼠标位置：实时显示数值

#### 3.3 终端窗口

点击"弹出终端窗口"按钮打开独立窗口，功能与内嵌终端相同。

---

### 四、主题设置

软件支持深色/浅色两种主题：
- 深色主题（默认）：深色背景，紫色高亮
- 浅色主题：浅色背景，蓝色高亮

通过工具栏的下拉框切换主题，主题设置会自动保存。

---

### 五、配置保存

软件会自动保存以下配置到 `config.json`：

| 配置项 | 说明 |
|--------|------|
| 窗口位置和大小 | 上次关闭时的窗口状态 |
| 主题 | 当前使用的主题 |
| 串口配置 | 上次使用的串口参数 |
| 编码设置 | 发送/接收编码 |
| 界面显示 | 各个区域的显示状态 |
| 协议列表 | 已加载的协议 |
| 键盘映射 | 快捷键配置 |

配置会在窗口移动、大小变化、关闭时自动保存。

---

## 协议文件格式

### JSON协议文件示例

（在图形化界面配置点击保存就行）

```json
{
  "structName": "MyPacket",
  "endian": "little",
  "fields": [
    {"name": "ID", "type": "uint8"},
    {"name": "DATA_LEN", "type": "uint8"},
    {"name": "VALUE_X", "type": "float"},
    {"name": "VALUE_Y", "type": "float"},
    {"name": "CHECKSUM", "type": "uint8"}
  ],
  "verify": "xor",
  "align": 1,
  "header": 90,
  "header_len": 1,
  "footer": 255,
  "footer_len": 1,
  "data_len": false,
  "data_len_mode": "data_only"
}
```

### 字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| structName | string | 结构体名称 |
| endian | string | 字节序：little / big |
| fields | array | 字段列表 |
| fields[].name | string | 字段名称 |
| fields[].type | string | 数据类型：int, uint8, uint16, int8, int16, float, char, bool |
| fields[].length | int | 字段长度（仅char类型需要） |
| verify | string | 校验方式：none, crc8, crc16, sum, xor |
| align | int | 字节对齐：1, 2, 4, 8 |
| header | int | 帧头值（十进制） |
| header_len | int | 帧头字节数 |
| footer | int | 帧尾值（十进制） |
| footer_len | int | 帧尾字节数 |
| data_len | bool | 是否包含数据长度字段 |
| data_len_mode | string | 长度模式：data_only, with_checksum, full_frame |

### 示例协议文件

软件自带多个示例协议，位于 `./examples/` 目录：
- `CAR_Packet.json` - 车辆通信协议
- `example.json` - 示例
- `CAR_send_Packet.json` - 车辆发送协议
- `SHAOBING.json` - 烧饼发送协议

---

## 常见问题

### 1. 串口打不开
- 检查串口是否被其他程序占用
- 确认串口名称正确（Windows下如COM3）
- 尝试刷新串口列表

### 2. 接收数据乱码
- 尝试切换接收编码（GBK/UTF-8）
- 确认发送端和接收端使用相同的编码

### 3. 帧解析失败
- 确认协议文件格式正确（有效的JSON）
- 确认帧头帧尾设置正确
- 检查字节序是否匹配（小端/大端）
- 确认校验方式正确
- 尝试手动解析测试

### 4. 示波器不显示
- 确保已安装 matplotlib 和 numpy
- 确认已启用示波器
- 检查是否收到了数据

### 5. 快捷键不生效
- 点击"点击捕获"按钮
- 按下要绑定的按键
- 设置协议和值
- 勾选启用

---

## 代码生成说明

### 生成的文件

- `{StructName}_send.c` - C语言发送端代码
- `{StructName}_recv.c` - C语言接收端代码
- `{StructName}_send.cpp` - C++发送端代码
- `{StructName}_recv.cpp` - C++接收端代码
- `{StructName}_send.py` - Python发送端代码
- `{StructName}_recv.py` - Python接收端代码

### 生成的函数

| 函数 | 说明 |
|------|------|
| `encode()` | 编码：将结构体数据转换为字节流 |
| `decode()` | 解码：将字节流转换为结构体数据 |
| `calculate_verify()` | 计算校验值 |
| `verify_packet()` | 验证数据完整性 |

---

## 项目结构

```
uart_all_in_one/
│-- UartTool.exe          # 编译后的可执行文件
|-- examples/                  # 示例协议文件
├── datas/				# 示波器数据输出文件
│── projectfiles/  # 自动保存的配置文件存放地址
│   ├── config.json               # 配置文件
└── reademe.md    
```

---

## 打包发布

### 使用打包脚本

```bash
# 安装打包依赖
pip install pyinstaller

# 打包成 Windows exe
python project_files/tools/build.py win

# 打包成 Linux 可执行文件
python project_files/tools/build.py linux

# 清理构建文件
python project_files/tools/build.py clean
```

打包后的文件位于 `dist` 目录下。

---

## 环境要求

- **操作系统**：Windows 7+ / Ubuntu 16.04+
- **Python**：3.7+（如需运行源码）
- **依赖**：PyQt5, pyserial, matplotlib, numpy

---

## 技术支持

如有问题，请检查：
1. 串口驱动是否正确安装
2. 协议配置是否正确
3. 数据编码是否匹配

---

## 更新日志

### v1.1.0
- 新增独立帧解析窗口
- 新增独立示波器窗口（支持变量选择和类型转换）
- 新增独立终端窗口
- 新增键盘映射功能（8个快捷键）
- 新增主题切换功能
- 优化配置自动保存

### v1.0.0
- 初始版本
- 支持代码生成（C/C++/Python）
- 支持串口调试
- 支持帧解析
- 支持串口示波器
